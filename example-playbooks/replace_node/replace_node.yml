---
- name: Prepare nodes before replacement
  hosts: scylla
  become: true
  tasks:
    - name: Resolve a scylla_listen_address as a fact
      set_fact:
        listen_address: "{{ scylla_listen_address }}"

    - name: Resolve scylla_broadcast_address as a fact
      set_fact:
        broadcast_address: "{{ scylla_broadcast_address }}"

    - name: Check if CQL port is up on {{ hostvars[replaced_node]['listen_address'] }}
      wait_for:
        port: 9042
        host: "{{ hostvars[replaced_node]['listen_address'] }}"
        timeout: 60
      register: _wait_for_cql_port_output
      ignore_errors: true
      delegate_to: "{{ replaced_node }}"
      run_once: true

    - name: Validate that the node being replaced is down
      fail:
        msg: "The node must be down in order to be replaced!"
      when: _wait_for_cql_port_output.failed|bool == false
      run_once: true

    - name: Check if the other nodes are UP
      wait_for:
        port: 9042
        host: "{{ listen_address }}"
        timeout: 60
      when: inventory_hostname != replaced_node and inventory_hostname != new_node

    - name: Blacklist replaced node's broadcast_address to prevent it from trying to join the cluster again
      iptables:
        chain: INPUT
        source: "{{ hostvars[replaced_node]['broadcast_address'] }}"
        jump: DROP
      when: inventory_hostname != replaced_node

    - name: Also blacklist listen_address, since scylla might use it when broadcast_address is omitted
      iptables:
        chain: INPUT
        source: "{{ hostvars[replaced_node]['listen_address'] }}"
        jump: DROP
      when: inventory_hostname != replaced_node

    # FIXME: Make sure this will work even if the dead node is the first of the list
    - name: Define any of the alive nodes as a seed
      set_fact:
        temporary_seed: "{{ hostvars[item]['listen_address'] }}"
      when: item != replaced_node and item != new_node
      loop: "{{ ansible_play_hosts_all }}"
      run_once: true

- name: Install Scylla in the new node
  hosts: "{{ new_node }}"
  become: true
  vars:
    start_scylla_service: false
  roles:
    - ansible-scylla-node

- name: Start Scylla in the new node
  hosts: "{{ new_node }}"
  become: true
  tasks:
    - name: Check if replace_node_first_boot is available in the current Scylla version
      shell: |
        scylla --help | grep replace-node-first-boot
      register: _replace_node_first_boot_grep
      ignore_errors: true

    - name: Set replace_node_first_boot
      block:
        - name: Get the host id for all nodes
          uri:
            url: "http://{{ scylla_api_address }}:{{ scylla_api_port }}/storage_service/host_id"
            method: GET
          register: _host_ids
          until: _host_ids.status == 200
          retries: 5
          delay: 1
          delegate_to: "{{ temporary_seed }}"

        - set_fact:
            _replaced_node_host_id: "{{ item.value }}"
          when: item.key == replaced_node
          loop: "{{ _host_ids.json }}"

        - name: Set replace_node_first_boot
          lineinfile:
            path: /etc/scylla/scylla.yaml
            regexp: '^(#\s*)?replace_node_first_boot:'
            line: "replace_node_first_boot: {{ _replaced_node_host_id }}"
            create: yes
      when: _replace_node_first_boot_grep.failed == false

    - name: Set replace_address_first_boot
      lineinfile:
        path: /etc/scylla/scylla.yaml
        regexp: '^(#\s*)?replace_address_first_boot:'
        line: "replace_address_first_boot: {{ replaced_node }}"
        create: yes
      when: _replace_node_first_boot_grep.failed

    - name: Start Scylla
      service:
        name: scylla-server
        state: started

    - name: Wait for CQL port on {{ listen_address }}
      wait_for:
        port: 9042
        host: "{{ listen_address }}"
        timeout: "{{ scylla_bootstrap_wait_time_sec }}"

    - name: Wait for the added node to become healthy
      shell: |
        nodetool status|grep -E '^UN|^UJ|^DN'|grep "{{ vars['ansible_'~scylla_nic].ipv4.address }}"| wc -l
      register: node_count
      until: node_count.stdout|int == 1
      retries: 300
      delay: 1

    - name: Remove the replace_node_first_boot record
      lineinfile:
        path: /etc/scylla/scylla.yaml
        regexp: '^replace_node_first_boot:'
        state: absent
      when: _replace_node_first_boot_grep.failed == false

    - name: Remove the replace_address_first_boot record
      lineinfile:
        path: /etc/scylla/scylla.yaml
        regexp: '^replace_address_first_boot:'
        state: absent
      when: _replace_node_first_boot_grep.failed

    - name: Check if RBNO is available in the current Scylla version
      shell: |
        scylla --help | grep enable-repair-based-node-ops
      register: _enable_rbno_grep
      ignore_errors: true

    - name: Check if RBNO is enabled for node replacement
      block:
        - command: cat /etc/scylla/scylla.yaml
          ignore_errors: true
          register: _scylla_yaml_out

        - set_fact:
            _scylla_yaml_map: "{{ _scylla_yaml_out.stdout | from_yaml }}"

        - set_fact:
            _rbno_enabled: |
              {% if (_scylla_yaml_map.enable_repair_based_node_ops is not defined or _scylla_yaml_map.enable_repair_based_node_ops == true) %}True{% else %}False{% endif %}
            _rbno_allowed_for_replace: |
              {% if (_scylla_yaml_map.allowed_repair_based_node_ops is not defined or 'replace' in _scylla_yaml_map.allowed_repair_based_node_ops) %}True{% else %}False{% endif %}
      when: _enable_rbno_grep.failed == false

- name: Repair the new node, if necessary
  hosts: scylla-manager
  become: true
  tasks:
    # FIXME: Remember to test this
    - name: Skip this playbook if RBNO was used for the replacement
      meta: end_host
      when: hostvars[new_node]['_enable_rbno_grep'].failed == false and hostvars[new_node]['_rbno_enabled'] and hostvars[new_node]['_rbno_allowed_for_replace']

    - name: Get cluster id
      shell: |
        sctool status | grep 'Cluster: {{ scylla_cluster_name }} ' | awk '{print $3}' | tr -d '()'
      register: _cluster_id

    - fail:
        msg: "Unable to find cluster {{ scylla_cluster_name }} in scylla-manager"
      when: _cluster_id.stdout|length == 0

    - name: Repair the new node
      shell: |
        sctool repair --cluster "{{ _cluster_id.stdout }}" --host "{{ new_node }}"
      register: _repair_id

    - name: Wait for the repair to finish
      shell:
        sctool progress "{{ _repair_id.stdout }}" --cluster "{{ _cluster_id.stdout }}" | grep "Status:" | awk '{print $2}'
      register: _repair_status
      until: _repair_status.stdout != "RUNNING"
      retries: "{{ repair_timeout_seconds|int // 30 }}" # retries = repair_timeout_seconds / delay
      delay: 30

    - fail:
        msg: "Repair failed!"
      when: _repair_status.stdout != "DONE"
